// Generated by CoffeeScript 2.7.0
(function() {
  var $, autoRefresh, baseName, canvases, clearAll, dataURItoBlob, downloadCanvas, downloadZip, drawText, files, fontStacks, formatValue, graph, imageInput, input, inputItems, makeId, makeStyle, readFiles, refresh, removeEntry, updateActions, updateValue, valueDisplays,
    indexOf = [].indexOf;

  $ = function(sel) {
    return document.querySelector(sel);
  };

  inputItems = ['text', 'font', 'color', 'alpha', 'angle', 'space', 'size'];

  input = {};

  valueDisplays = {
    alpha: document.querySelector('#alpha-value'),
    angle: document.querySelector('#angle-value'),
    space: document.querySelector('#space-value'),
    size: document.querySelector('#size-value')
  };

  imageInput = $('#image');

  graph = $('#graph');

  refresh = $('#refresh');

  autoRefresh = $('#auto-refresh');

  clearAll = $('#clear-all');

  downloadZip = $('#download-zip');

  files = [];

  canvases = [];

  makeId = function() {
    return Math.random().toString(36).slice(2, 10);
  };

  baseName = function(name) {
    return (name != null ? name.replace(/(\.[^.]+)?$/, '') : void 0) || 'watermark';
  };

  dataURItoBlob = function(dataURI) {
    var arr, binStr, i, k, len, ref;
    binStr = atob((dataURI.split(','))[1]);
    len = binStr.length;
    arr = new Uint8Array(len);
    for (i = k = 0, ref = len - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {
      arr[i] = binStr.charCodeAt(i);
    }
    return new Blob([arr], {
      type: 'image/png'
    });
  };

  updateActions = function() {
    var hasCanvas, hasFiles;
    hasFiles = (files != null ? files.length : void 0) > 0;
    hasCanvas = (canvases != null ? canvases.length : void 0) > 0;
    if (clearAll != null) {
      clearAll.toggleAttribute('disabled', !hasFiles);
    }
    return downloadZip != null ? downloadZip.toggleAttribute('disabled', (!hasCanvas) || (window.JSZip == null)) : void 0;
  };

  downloadCanvas = function(canvas, name) {
    var blob, imageData, link;
    link = document.createElement('a');
    link.download = baseName(name) + '-marked.png';
    imageData = canvas.toDataURL('image/png');
    blob = dataURItoBlob(imageData);
    link.href = URL.createObjectURL(blob);
    graph.appendChild(link);
    return setTimeout(function() {
      link.click();
      return graph.removeChild(link);
    }, 60);
  };

  removeEntry = function(id) {
    files = files.filter(function(item) {
      return item.id !== id;
    });
    return readFiles();
  };

  readFiles = function() {
    graph.innerHTML = '';
    canvases = [];
    if (!(files != null ? files.length : void 0)) {
      return updateActions();
    }
    files.forEach(function(entry) {
      var canvas, card, delBtn, file, fileReader, id, name;
      ({file, id, name} = entry);
      card = document.createElement('div');
      card.className = 'preview-card';
      delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = '删除';
      delBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        return removeEntry(id);
      });
      canvas = document.createElement('canvas');
      card.appendChild(delBtn);
      card.appendChild(canvas);
      graph.appendChild(card);
      fileReader = new FileReader();
      fileReader.onload = function() {
        var img;
        img = new Image();
        img.onload = function() {
          var ctx;
          canvas.width = img.width;
          canvas.height = img.height;
          ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          canvases.push({canvas, ctx, img, name, id});
          canvas.addEventListener('click', function() {
            return downloadCanvas(canvas, name);
          });
          drawText();
          return updateActions();
        };
        return img.src = fileReader.result;
      };
      return fileReader.readAsDataURL(file);
    });
    return updateActions();
  };

  makeStyle = function() {
    var match, ref;
    match = (ref = input.color.value) != null ? ref.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i) : void 0;
    if (match == null) {
      return 'rgba(29,155,240,' + input.alpha.value + ')';
    }
    return 'rgba(' + (parseInt(match[1], 16)) + ',' + (parseInt(match[2], 16)) + ',' + (parseInt(match[3], 16)) + ',' + input.alpha.value + ')';
  };

  fontStacks = {
    system: '-apple-system,"Helvetica Neue",Helvetica,Arial,"PingFang SC","Hiragino Sans GB","WenQuanYi Micro Hei",sans-serif',
    inter: '"Inter",-apple-system,"Helvetica Neue",Helvetica,Arial,"PingFang SC","Hiragino Sans GB","WenQuanYi Micro Hei",sans-serif',
    noto: '"Noto Sans SC","PingFang SC","Hiragino Sans GB","WenQuanYi Micro Hei",sans-serif',
    mono: '"SFMono-Regular",Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'
  };

  formatValue = function(key, val) {
    switch (key) {
      case 'alpha':
        return Math.round(val * 100) + '%';
      case 'angle':
        return Math.round(val) + '°';
      case 'space':
        return val.toFixed(1) + 'x';
      case 'size':
        return val.toFixed(2) + 'x';
      default:
        return val;
    }
  };

  updateValue = function(key) {
    var display, val;
    display = valueDisplays[key];
    if (display == null) {
      return;
    }
    val = parseFloat(input[key].value);
    return display.textContent = formatValue(key, val);
  };

  drawText = function() {
    if (!canvases.length) {
      return;
    }
    canvases.forEach(function({canvas, ctx, img}) {
      var fontName, i, j, k, l, margin, ref, ref1, ref2, ref3, step, text, textSize, width, x, y;
      textSize = input.size.value * Math.max(15, (Math.min(canvas.width, canvas.height)) / 25);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(input.angle.value * Math.PI / 180);
      ctx.fillStyle = makeStyle();
      fontName = fontStacks[input.font.value] || fontStacks.system;
      ctx.font = 'bold ' + textSize + 'px ' + fontName;
      text = input.text.value || '内部水印';
      width = (ctx.measureText(text)).width;
      step = Math.sqrt((Math.pow(canvas.width, 2)) + (Math.pow(canvas.height, 2)));
      margin = (ctx.measureText('啊')).width;
      x = Math.ceil(step / (width + margin));
      y = Math.ceil((step / (input.space.value * textSize)) / 2);
      for (i = k = ref = -x, ref1 = x; (ref <= ref1 ? k <= ref1 : k >= ref1); i = ref <= ref1 ? ++k : --k) {
        for (j = l = ref2 = -y, ref3 = y; (ref2 <= ref3 ? l <= ref3 : l >= ref3); j = ref2 <= ref3 ? ++l : --l) {
          ctx.fillText(text, (width + margin) * i, input.space.value * textSize * j);
        }
      }
      return ctx.restore();
    });
  };

  if (clearAll != null) {
    clearAll.addEventListener('click', function() {
      files = [];
      canvases = [];
      graph.innerHTML = '';
      imageInput.value = '';
      return updateActions();
    });
  }

  if (downloadZip != null) {
    downloadZip.addEventListener('click', function() {
      var tasks, zip;
      if (!((window.JSZip != null) && canvases.length)) {
        return;
      }
      zip = new JSZip();
      tasks = canvases.map(function({canvas, name}) {
        return new Promise(function(resolve, reject) {
          return canvas.toBlob(function(blob) {
            if (blob == null) {
              return reject(new Error('生成失败'));
            }
            zip.file(baseName(name) + '-marked.png', blob);
            return resolve();
          });
        });
      });
      return Promise.all(tasks).then(function() {
        return zip.generateAsync({
          type: 'blob'
        });
      }).then(function(content) {
        var link;
        link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = 'watermarks.zip';
        document.body.appendChild(link);
        return setTimeout(function() {
          link.click();
          return document.body.removeChild(link);
        }, 60);
      }).catch(function(err) {
        return console.error(err);
      });
    });
  }

  imageInput.addEventListener('change', function() {
    var additions, invalid, selected, validTypes;
    selected = Array.from(this.files || []);
    validTypes = ['image/png', 'image/jpeg', 'image/gif'];
    invalid = selected.filter(function(item) {
      var ref;
      return ref = item.type, indexOf.call(validTypes, ref) < 0;
    });
    additions = selected.filter(function(item) {
      var ref;
      return ref = item.type, indexOf.call(validTypes, ref) >= 0;
    });
    files = files.concat(additions.map(function(file) {
      return {
        file: file,
        id: makeId(),
        name: file.name
      };
    }));
    if (invalid.length) {
      alert('已忽略非 png/jpg/gif 的文件');
    }
    if (!files.length) {
      return alert('请选择 png / jpg / gif 图片');
    }
    imageInput.value = '';
    return readFiles();
  });

  autoRefresh.addEventListener('change', function() {
    if (this.checked) {
      return refresh.setAttribute('disabled', 'disabled');
    } else {
      return refresh.removeAttribute('disabled');
    }
  });

  autoRefresh.addEventListener('change', function() {
    if (this.checked) {
      return refresh.setAttribute('disabled', 'disabled');
    } else {
      return refresh.removeAttribute('disabled');
    }
  });

  autoRefresh.addEventListener('change', function() {
    if (this.checked) {
      return refresh.setAttribute('disabled', 'disabled');
    } else {
      return refresh.removeAttribute('disabled');
    }
  });

  inputItems.forEach(function(item) {
    var el;
    el = $('#' + item);
    input[item] = el;
    return el.addEventListener('input', function() {
      updateValue(item);
      if (autoRefresh.checked) {
        return drawText();
      }
    });
  });

  refresh.addEventListener('click', drawText);

  inputItems.forEach(function(item) {
    return updateValue(item);
  });

}).call(this);
